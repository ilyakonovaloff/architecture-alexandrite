# Трейсинг

## Ключевые места, где заказ может "зависнуть" или сломаться

| Этап                                               | Компонент          | Потенциальные проблемы                                      |
|----------------------------------------------------|--------------------|-------------------------------------------------------------|
| `INITIATED` → `SUBMITTED`                          | **Онлайн-магазин** | Потеря данных корзины, проблема на UI, сбой API             |
| `SUBMITTED` → `PRICE_CALCULATED`                   | **MES**            | Сообщение теряется, не доходит или попадает в DLQ           |
| `PRICE_CALCULATED` → `MANUFACTURING_APPROVED`      | **CRM**            | Заказ не появляется или не обрабатывается в CRM             |
| `MANUFACTURING_APPROVED` → `MANUFACTURING_STARTED` | **MES**            | Оператор не видит заказ (UI тормозит / фильтр не работает)  |
| `MANUFACTURING_STARTED` → `SHIPPED`                | **MES**            | Отсутствие перехода между статусами, ошибки в UI или логике |
| `SHIPPED` → `CLOSED`                               | **CRM**            | Сбой в получении статуса доставки от ТК, ручное закрытие    |

---

## Что покрывать и зачем

1. **Shop API**: понять, что именно пользователь заказал, как сформировался заказ.
2. **RabbitMQ**: выявлять потерю сообщений, застревание, DLQ.
3. **MES (pricing, manufacturing)**: контролировать расчёт стоимости, запуск и завершение производства.
4. **CRM**: проверять, когда заказ принят, одобрен, закрыт.

---

## Список данных, которые должны попадать в трейсинг

| Поле                                | Назначение                                        |
|-------------------------------------|---------------------------------------------------|
| `trace_id`                          | Общий идентификатор всей цепочки запроса / заказа |
| `timestamp_start` / `timestamp_end` | Время начала и конца действия                     |
| `duration_ms`                       | Продолжительность действия                        |
| `status`                            | Успешно/ошибка (OK/ERROR)                         |
| `error_message`                     | Текст ошибки (если есть)                          |
| `order_id`                          | Идентификатор заказа                              |
| `customer_id`                       | Идентификатор клиента                             |
| `external_partner_id`               | Идентификатор партнёра (если заказ через API)     |
| `model_id`                          | ID 3D-модели                                      |

---

## Мотивация

На текущий момент платформа "Александрит" не позволяет отслеживать путь заказа сквозь все компоненты системы: от онлайн-магазина, через CRM и MES, до отгрузки. Это создаёт "слепые зоны" — невозможно понять:  
* где заказ "завис" или потерялся,
* на каком этапе возникла ошибка,
* кто ответственен за задержку,
* сколько времени уходит на отдельные этапы.

Трейсинг позволяет получить сквозную видимость заказов и событий в системе. Он фиксирует каждый шаг прохождения запроса между сервисами, включая задержки, ошибки, статусы, ID-заказов и пользователей.

### Что даст трейсинг компании

#### Технические преимущества:

1. **Сокращение времени на диагностику (MTTR)**
   → Быстрее находить причину инцидента: где именно и почему "сломалось".

2. **Обнаружение "узких мест" и аномалий**
   → Выявлять задержки в расчётах (MES), зависания в очередях (RabbitMQ), недоступность API.

3. **Повышение качества кода и интеграций**
   → Инженеры видят конкретные последовательности вызовов и могут выявлять неочевидные зависимости или баги.

4. **Прозрачность работы сервисов и очередей**
   → Особенно важно, учитывая взаимодействие через RabbitMQ между MES и CRM.

---

#### Бизнес-метрики:

1. **Снижение числа жалоб от клиентов и партнёров**
   → За счёт более быстрой реакции на реальные сбои и проактивного мониторинга.

2. **Повышение SLA и доверия со стороны B2B-партнёров**
   → Сейчас заказы от API-партнёров теряются — трейсинг даст контроль и прозрачность.

3. **Оптимизация бизнес-процессов и расчётов**
   → Точное понимание, сколько времени занимает каждый шаг и почему происходит перерасход времени.

---

## Предлагаемое решение

Выбираем **OpenTelemetry** как стандарт де-факто для сбора трейсинга и **Jaeger** как систему визуализации, хранения и анализа трейсинговых данных. Это open-source стек, хорошо поддерживаемый для Java, C#, JS и RabbitMQ.

---

### Технологии

| Компонент            | Технология                         |
|----------------------|------------------------------------|
| Сбор трейсинга       | OpenTelemetry SDK (Java, .NET, JS) |
| Транспорт трейсинга  | OTLP (gRPC/HTTP)                   |
| Агрегация и хранение | Jaeger Collector + Jaeger UI       |
| Хранение трейсов     | Jaeger                             |
| Визуализация         | Jaeger UI                          |

---

### Компоненты, подлежащие доработке

#### Онлайн-магазин (Vue + Spring Boot)

* Внедрить OpenTelemetry SDK в backend Java.
* Инструментировать входящие HTTP-запросы, вызовы к CRM, загрузку моделей, генерацию заказов.
* Проксировать вызовы к CRM и MES с передачей trace-id.

#### CRM (Vue + Spring Boot)

* Внедрить OpenTelemetry SDK в backend Java.
* Инструментировать:
    * работу с RabbitMQ,
    * обновление статусов,
    * ответы пользователям API.

#### MES (React + C# backend)

* Внедрить OpenTelemetry SDK в backend .NET.
* Инструментировать:
    * расчёт стоимости,
    * работу операторов,
    * входящие/исходящие вызовы,
    * отправку данных в RabbitMQ.

[Схема](https://drive.google.com/file/d/1BJvrBvwlE9Av3a1nRdkjKs4vibwbFeYE/view?usp=sharing)

### Автоматический мониторинг процесса прохождения заказа

### 1. Создание спанов

В каждом приложении (магазин, CRM, MES) при изменении статуса заказа (например, `SUBMITTED`, `PRICE_CALCULATED`, `MANUFACTURING_STARTED`) создаётся span с `order_id`, `status` и `timestamp`.

---

### 2. Создание метрик на основе данных трейсинга

* Принимает трейсы.
* Обрабатываем их, добавляя атрибуты (например, `service.name`, `order.status`, `duration`).
* Преобразуем нужные данные в метрики.
* Отправляем метрики в **Prometheus**.
---

### 3. Дашборды и Алертинг (Grafana + Alertmanager)

Примеры алертов:

| Условие                                                             | Действие               |
|---------------------------------------------------------------------|------------------------|
| `order_stage_duration_seconds > 900` (15 мин)                       | Slack / Telegram alert |
| `order_status_count{status="PRICE_CALCULATED"}` не менялся > 10 мин | Email DevOps           |
| Заказ > 2 часа в статусе `MANUFACTURING_STARTED`                    | Создание тикета в JIRA |


[Схема](https://drive.google.com/file/d/1ZnoWTWFQtoI9NAINpINqTbs9qJ6bxvt4/view?usp=sharing)

---

## Компромиссы

### 1. Высокая стоимость внедрения и сопровождения

Для трейсинга требуется изменение всех backend-приложений, интеграция SDK OpenTelemetry, настройка экспортёров, инфраструктуры хранения (Jaeger), безопасность, мониторинг самого трейсинга.

---

### 2. Нагрузка на сеть и хранилище

Трейсы, особенно детализированные (с большим количеством спанов), создают существенную нагрузку при пиковых объёмах заказов.

---

### Вывод

На первом этапе его целесообразно внедрять только в **CRM**, **MES** с небольшим количеством спанов, для каждого сервиса по два спана - первый спан соответствует входящему запросу, а второй исходящему.

---

## Безопасность

### Аутентификация и авторизация

Настроить аутентификацию через корпоративный Identity Provider (например, Keycloak, либо SSO через OAuth/SAML). Доступ разрешён только ролям **Поддержка**, **DevOps**, **Разработчик**.

---

### Ограничение внешнего доступа

Интерфейс трейсинга должен быть доступен только из внутренней сети компании или через VPN.

---

### Скрытие чувствительных данных

Поля с персональной информацией шифруются или заменяются на заглушки.

---

### Шифрование трафика

Весь трафик к UI и API трейсера проходит по **HTTPS/TLS 1.2+**.

---

### Ограничение хранения данных

Внедрить ротацию данных и ограничение хранения — например, хранить трейсы не более 14 дней.
